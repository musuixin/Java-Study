package top.musuixin.algo;

import java.util.Scanner;

public class ALGO2 {
    /**
     * 在一组数中找三个数，使他们的最小公倍数最大，我们知道，两个数的最小公倍数在最大的情况就是当两个数互质的时候，他们
     * 的最小公倍数就是这两个数的乘积，而且还有那么一个定理，即两个相邻的自然数互质，即使我们不知道定理怎么证明，但大体能想出
     * 来，但这是三个数，也就是说存在 奇-偶-奇 和 偶-奇-偶 两种情况。
     *
     * 一：奇-偶-奇 这种情况用于n是奇数的情况，即 最大的三个数就是 n，n-1，n-2，那么可以看到，因为n和n-
     * 2都是奇数，所以肯定不存在公因数2，假设三个数中有一个存在因数3，那么另外两个肯定不存在因数3，因为他们的变化范围都
     * 小于3，也就是说，这三个数不仅是最大的，还是互质的，也就是说最大的最小公倍数就是这三个数的乘积，即n*（n-1）*（n-2）相信大部分人都可以想到这一步
     *
     *
     * 二：偶-奇-偶 对于这种情况两个偶数肯定是存在公因数2，也就是意味着最小公倍数要除以2，这是绝对不能容忍的，
     * 所以我们稍微缩小一下数，即n，n-1，n-3，这样就又变成奇-偶-奇的结构了，但还有一个问题，就是假如偶数n存在因数3，
     * 那么n-3也必定有因数3，这直接导致最小公倍数除以3，更加不能容忍，为了保持奇-偶-奇的结构不变，只能变那个偶数，而离他
     * 最近的偶数就是n-2了，这下就完美了，3个数依然是互质的，最小公倍数就是（n-1）（n-2）（n-3）
     * @param args
     */
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        long n = scanner.nextInt();
        long ans;
        if(n%2==1) {
            ans=n*(n-1)*(n-2);
        }
        else {
            if(n%3==0) {
                ans=(n-1)*(n-2)*(n-3);
            } else {
                ans=n*(n-1)*(n-3);
            }
        }
        System.out.println(ans);
    }
}
